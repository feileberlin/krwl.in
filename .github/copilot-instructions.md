# Copilot Instructions for KRWL HOF Community Events

## Project Overview

KRWL HOF is a **mobile-first Progressive Web App (PWA)** for discovering community events with interactive map visualization. The project uses a Python backend for event scraping/management and a vanilla JavaScript frontend with Leaflet.js for mapping.

### Architecture
- **Backend**: Python 3.x with modular TUI (Text User Interface)
- **Frontend**: Vanilla JavaScript (no frameworks), Leaflet.js for maps
- **Deployment**: Static site generation ‚Üí GitHub Pages
- **Data Flow**: Scraping ‚Üí Pending queue ‚Üí Editorial review ‚Üí Published events

## Technology Stack

### Backend (Python)
- **Core**: Python 3.x, modular design
- **Dependencies**: requests>=2.31.0, beautifulsoup4>=4.12.0, lxml>=4.9.0, feedparser>=6.0.10 (see `requirements.txt`)
- **Key Modules**:
  - `src/main.py` - TUI entry point and CLI
  - `src/modules/scraper.py` - Event scraping (RSS, HTML, API)
  - `src/modules/editor.py` - Editorial workflow
  - `src/modules/builder.py` - Unified build system (libs + HTML generation)
  - `src/modules/filter_tester.py` - Filter testing
  - `src/modules/feature_verifier.py` - Feature registry validation

### Frontend (JavaScript)
- **Framework**: None (vanilla JS)
- **Maps**: Leaflet.js
- **PWA**: Manifest.json for installability (service worker planned for future)
- **i18n**: Custom implementation (`static/js/i18n.js`)
- **Files**: 
  - `static/index.html` - Main app
  - `static/js/app.js` - App logic
  - `static/css/style.css` - Styles

### Configuration

**IMPORTANT: Automatic Environment Detection**

This project uses a **single unified config file** (`config.json`) with automatic environment detection that works across **all major hosting platforms**:

- **config.json** - Unified configuration with smart defaults that automatically adapt based on environment
  - Local Development: `debug=true`, `data.source="both"` (real + demo events), `watermark="DEV"`
  - CI/Production: `debug=false`, `data.source="real"`, `watermark="PRODUCTION"`

**How It Works:**
- Environment is detected automatically using `os.environ` checks in Python
- **CI Detection**: Automatically detects GitHub Actions, GitLab CI, Travis CI, CircleCI, Jenkins, Bitbucket Pipelines, Azure Pipelines, AWS CodeBuild
- **Production Detection**: Automatically detects Vercel, Netlify, Heroku, Railway, Render, Fly.io, Google Cloud Run, AWS, or explicit `NODE_ENV=production`
- **Development**: Default when NOT in CI and NOT in production (typical for local developers)

**Supported Hosting Platforms:**
- ‚úÖ GitHub Pages (via GitHub Actions CI detection)
- ‚úÖ Vercel (via VERCEL_ENV)
- ‚úÖ Netlify (via NETLIFY + CONTEXT)
- ‚úÖ Heroku (via DYNO)
- ‚úÖ Railway (via RAILWAY_ENVIRONMENT)
- ‚úÖ Render (via RENDER)
- ‚úÖ Fly.io (via FLY_APP_NAME)
- ‚úÖ Google Cloud Run (via K_SERVICE)
- ‚úÖ AWS (via AWS_EXECUTION_ENV)
- ‚úÖ Any platform with NODE_ENV=production

**NO MANUAL SWITCHING NEEDED** - Deploy to any platform and it automatically adapts!

See detailed documentation in the "Project Configuration" section below.

## Critical: Auto-Generated Files üö´

**DO NOT manually edit this file** - it is generated by `src/modules/builder.py`:
- `static/index.html` - Single-file HTML with everything inlined

### To modify the HTML:
1. Edit source CSS/JS files: `static/css/style.css`, `static/js/app.js`, `static/js/i18n.js`
2. Or edit templates in `src/modules/builder.py` (for advanced changes)
3. Run: `python3 src/main.py build production` (or `development`)
4. Commit both source changes AND generated `static/index.html`

## Build and Test Instructions

### Setup
```bash
# Install dependencies
pip install -r requirements.txt

# Download frontend libraries (Leaflet.js)
python3 src/main.py libs

# Verify library integrity
python3 src/main.py libs verify
```

### Running Locally
```bash
# Start local server
cd static
python3 -m http.server 8000
# Open http://localhost:8000
```

### Testing (ALWAYS run before finalizing changes)

#### Quick Development Tests
```bash
# Feature verification (validates features.json registry)
python3 verify_features.py --verbose

# Scraper tests
python3 test_scraper.py --verbose

# Filter tests
python3 test_filters.py --verbose

# Event schema validation
python3 test_event_schema.py --verbose

# KISS principle compliance
python3 check_kiss.py --verbose

# Translation tests
python3 test_translations.py --verbose

# Scheduler tests
python3 test_scheduler.py --verbose
```

#### Documentation
```bash
# Regenerate README.md (auto-generated)
python3 scripts/generate_readme.py
```

#### Linting
- **Python**: Linting is advisory (warnings don't block PRs)
- **JavaScript**: ESLint for syntax checking
- **JSON**: Strict validation (blocks PRs on errors)

See `.github/workflows/lint.yml` for full linting configuration.

### Building the Application
```bash
# Build production HTML (optimized, real events only)
python3 src/main.py build production

# Build development HTML (with demo events and DEV badge)
python3 src/main.py build development

# Fast event update (after scraping or publishing, no full rebuild)
python3 src/main.py events

# Legacy command (still works, uses builder)
python3 src/main.py generate
```

## Code Guidelines

### KISS Principle (Keep It Simple, Stupid)
This project follows **strict KISS principles**. Always:
- Minimize complexity
- Avoid over-engineering
- Use vanilla solutions over frameworks when possible
- Keep files small and focused
- Avoid unnecessary abstractions

**Enforcement**: `check_kiss.py` validates KISS compliance. Review `src/modules/kiss_checker.py` for rules.

### Python Style
- **Python 3.x** standard library preferred
- **Type hints**: Not required but appreciated
- **Docstrings**: Use for modules and complex functions
- **Error handling**: Comprehensive try/except blocks
- **Module structure**: Keep modules under 1000 lines

### JavaScript Style
- **ES6+** features are okay (async/await, arrow functions, etc.)
- **No frameworks**: Vanilla JS only (Leaflet.js is the only external library)
- **Progressive Enhancement**: App must work without JavaScript for basic content
- **Mobile First**: Always test on mobile viewport sizes

### CSS Style
- **Mobile First**: Write for mobile, enhance for desktop
- **CSS Variables**: Use for theming (see `static/css/style.css`)
- **Responsive**: Use media queries, flexbox, grid
- **Accessibility**: Ensure sufficient contrast, focus indicators

## Project Configuration

### Environment Detection (IMPORTANT)

This project uses **automatic environment detection** with smart defaults. Configuration is stored in a single unified file (`config.json`) that intelligently adapts based on where the code runs.

#### Environment Modes

- **Local Development** (developer's machine):
  - `debug = true` - Verbose logging and debug features enabled
  - `data.source = "both"` - Load both real events AND demo events for testing
  - `watermark.text = "DEV"` - Show DEV watermark in UI
  - `app.name` includes `[DEV]` suffix
  - `performance.cache_enabled = false` - Fresh data on each load
  - `performance.prefetch_events = false` - On-demand loading
  - **Detection**: Automatically detected when NOT in CI and NOT in production

- **CI/Production** (All major CI systems and hosting platforms):
  - `debug = false` - Production mode, minimal logging
  - `data.source = "real"` - Only real scraped events (no demo data)
  - `watermark.text = "PRODUCTION"` - Show PRODUCTION watermark
  - `app.name` without `[DEV]` suffix
  - `performance.cache_enabled = true` - Enable caching for speed
  - `performance.prefetch_events = true` - Preload events for performance
  - **Detection**: Automatic via platform-specific environment variables (see list below)

#### How Environment Detection Works

The configuration system uses Python's `os.environ` to automatically detect the environment across all major platforms:

**CI Detection** - Checks for these environment variables:
- `CI` - Generic CI flag (most CI systems)
- `GITHUB_ACTIONS` - GitHub Actions
- `GITLAB_CI` - GitLab CI
- `TRAVIS` - Travis CI
- `CIRCLECI` - CircleCI
- `JENKINS_HOME` / `JENKINS_URL` - Jenkins
- `BITBUCKET_BUILD_NUMBER` - Bitbucket Pipelines
- `TF_BUILD` - Azure Pipelines
- `CODEBUILD_BUILD_ID` - AWS CodeBuild

**Production Detection** - Checks for these environment variables:
- `NODE_ENV=production` - Explicit production setting
- `VERCEL_ENV=production` - Vercel
- `NETLIFY=true` + `CONTEXT=production` - Netlify
- `DYNO` - Heroku
- `RAILWAY_ENVIRONMENT=production` - Railway
- `RENDER=true` - Render
- `FLY_APP_NAME` - Fly.io
- `K_SERVICE` - Google Cloud Run
- `AWS_EXECUTION_ENV` - AWS (non-Lambda)

**Development Detection** - Default when neither CI nor production

See `src/modules/utils.py` for the complete implementation:

```python
import os

def is_ci():
    """Detect if running in CI environment"""
    ci_indicators = ['CI', 'GITHUB_ACTIONS', 'GITLAB_CI', 'TRAVIS', 
                     'CIRCLECI', 'JENKINS_HOME', 'BITBUCKET_BUILD_NUMBER',
                     'TF_BUILD', 'CODEBUILD_BUILD_ID']
    return any(os.environ.get(var) for var in ci_indicators)

def is_production():
    """Detect if running in production"""
    # Checks for Vercel, Netlify, Heroku, Railway, Render, 
    # Fly.io, Google Cloud Run, AWS, or NODE_ENV=production
    # See full implementation in src/modules/utils.py
    ...

def is_development():
    """Detect if running in local development"""
    return not is_production() and not is_ci()
```

#### Configuration Loading

The `load_config()` function in `src/modules/utils.py` handles automatic environment detection:

```python
from src.modules.utils import load_config

# Automatically detects environment and applies appropriate overrides
config = load_config(base_path)

# Logs which mode is active: "üöÄ Running in development mode (debug: True, data source: both)"
# Or: "üöÄ Running in ci mode (debug: False, data source: real)"
# Or: "üöÄ Running in production mode (debug: False, data source: real)"
```

#### NO MANUAL SWITCHING NEEDED

The beauty of this system is that **you never need to manually switch configurations**:
- Developers working locally get debug mode automatically
- CI systems get production mode automatically
- **All hosting platforms get production mode automatically** - Just deploy and it works!
- Deployed production sites get production mode automatically

Just write your code and let the environment detection handle the rest!

#### Configuration File Structure

The unified `config.json` contains:
- Inline comments (using `_comment_*` keys) explaining auto-detection behavior
- Base configuration values (defaults used for production/CI)
- All sections: `app`, `debug`, `watermark`, `performance`, `data`, `scraping`, `filtering`, `map`, `editor`

**Important**: The values in `config.json` represent the **base/production defaults**. Development-specific overrides are applied automatically by `load_config()` when running locally.

#### Environment Variables

Optional `.env` file (gitignored) can be used to force specific environment:
```bash
# Force production mode locally (rarely needed)
NODE_ENV=production

# Force development mode in CI (rarely needed)
# Leave empty or unset for automatic detection
```

See `.env.example` for the template.

### When Suggesting Code Changes

**ALWAYS follow these guidelines:**

1. **Never hardcode environment checks scattered throughout code**
   - ‚ùå Bad: `if os.environ.get('CI') == 'true': ...` in multiple files
   - ‚úÖ Good: Use `config['debug']`, `config['data']['source']` from centralized config

2. **Always use the centralized config loader with automatic detection**
   - Import: `from src.modules.utils import load_config`
   - Load: `config = load_config(base_path)`
   - Use: `if config['debug']: print("Debug info...")`

3. **Never suggest placing config in static folders** 
   - Security risk: Config files should stay in repository root
   - Never put `config.json` in `static/` directory

4. **Use environment flags from config object**
   - Debug mode: `if config['debug']:`
   - Data source: `source = config['data']['source']`
   - Watermark: `text = config['watermark']['text']`

5. **When adding new environment-specific behavior**
   - Add the setting to `config.json` with inline comments
   - Add override logic to `load_config()` in `src/modules/utils.py`
   - Document in this copilot instructions file

## Feature Registry System

All features must be documented in `features.json` with:
- Unique ID
- Name and description
- Category: `backend`, `frontend`, or `infrastructure`
- Implementation files
- Config keys (if applicable)
- Test method

**Validation**: Run `python3 verify_features.py` to ensure registry matches codebase.

When adding features:
1. Implement the feature
2. Add entry to `features.json`
3. Run `python3 verify_features.py --verbose` to validate

## Testing Requirements

### For Backend Changes
- Add/update tests in `test_*.py` files
- Run relevant test suite before committing
- Ensure tests pass in CI/CD

### For Frontend Changes
- Test in Chrome, Firefox, Safari
- Test on mobile devices (or Chrome DevTools mobile emulation)
- Verify PWA functionality (installability, offline mode)
- Check accessibility (keyboard navigation, screen readers)

### For Configuration Changes
- Test with both `config.dev.json` and `config.prod.json`
- Validate JSON syntax
- Run full test suite

## Deployment Workflow

Simplified workflow with two modes:

1. **Feature branch** ‚Üí PR to `main` branch
2. **Main branch** ‚Üí Auto-deploys to production (uses `config.prod.json`)

GitHub Pages serves the `static/` directory directly.

### Build Modes:
- **Production**: Real events only, optimized
- **Development**: Real + demo events, DEV badge shown

## Documentation Standards

### README.md
**AUTO-GENERATED** by `scripts/generate_readme.py`. Do not edit directly.
- Run `python3 scripts/generate_readme.py` to regenerate

### Code Documentation
- Python modules: Docstring at top of file
- Complex functions: Docstring explaining purpose, args, returns
- Configuration: Comments in JSON files (where parser allows)

### Markdown Files
- Use ATX-style headers (`#`, `##`, etc.)
- Include code blocks with language specifiers
- Add examples where helpful
- Keep lines under 120 characters when possible

## Workflow-Specific Guidelines

### Event Scraping
1. Configure source in `config.json` under `scraping.sources[]`
2. Implement scraper logic in `src/modules/scraper.py` if needed
3. Test with: `python3 test_scraper.py --verbose`
4. Scraped events go to `static/pending_events.json` for editorial review

### Editorial Workflow
1. Pending events require approval (unless `editor.auto_publish: true`)
2. Use TUI: `python3 src/main.py` ‚Üí "Review Pending Events"
3. Or use GitHub UI: Actions ‚Üí "Review Events (GitHub UI)" ‚Üí Run workflow
4. Actions: approve (a), edit (e), reject (r)
5. Approved events ‚Üí `static/events.json` ‚Üí appear on map
6. Approved events backed up to `backups/events/`

### Static Generation
1. HTML is generated by `src/modules/builder.py`
2. Generate: `python3 src/main.py build production` (or `development`)
3. Fast event update: `python3 src/main.py events` (no full rebuild)
4. Output: `static/index.html` (single-file HTML with everything inlined)
5. Data files live directly in `static/` (events.json, config files, etc.)

## Security Considerations

- **No secrets in code**: Use environment variables or config files (gitignored)
- **Input validation**: Always sanitize user input and scraped data
- **XSS protection**: Escape HTML when displaying user-generated content
- **HTTPS**: Production must use HTTPS (enforced by GitHub Pages)

## Common Tasks

### Add a new event source
1. Edit `config.prod.json` (production) or `config.dev.json` (development) in root directory
2. Add to `scraping.sources[]` array
3. Specify `type` (rss, html, api) and `url`
4. Test: `python3 src/main.py scrape`

### Build the application
1. For production: `python3 src/main.py build production`
2. For development: `python3 src/main.py build development`
3. Fast event update: `python3 src/main.py events`

### Add a new filter
1. Edit `static/js/app.js` (filter logic)
2. Edit `static/css/style.css` (filter UI styles)
3. Rebuild: `python3 src/main.py build production`
4. Test: `python3 test_filters.py --verbose`

### Add a new translation
1. Edit `static/content.json` (English)
2. Edit `static/content.de.json` (German)
3. Use in code: `i18n.t('key.path')`
4. Test: `python3 test_translations.py --verbose`

### Update documentation
1. Run: `python3 scripts/generate_readme.py` to regenerate README.md
2. Commit generated `README.md`

## Accessibility (A11y)

- **WCAG 2.1 Level AA** compliance required
- **Keyboard navigation**: All interactive elements must be keyboard accessible
- **ARIA labels**: Use for dynamic content and complex widgets
- **Color contrast**: Minimum 4.5:1 for normal text, 3:1 for large text
- **Focus indicators**: Visible focus styles required
- **Screen readers**: Test with NVDA (Windows) or VoiceOver (Mac/iOS)

## Performance

- **Page load**: Target < 3 seconds
- **Time to Interactive**: Target < 5 seconds
- **First Contentful Paint**: Target < 1.5 seconds
- **JavaScript bundle**: Keep minimal (vanilla JS helps)
- **Images**: Optimize, use SVG where possible
- **Caching**: Production uses aggressive caching via `config.prod.json`

## Git Workflow

### Commit Messages
- Use conventional commits: `feat:`, `fix:`, `docs:`, `test:`, `refactor:`, etc.
- Keep first line under 72 characters
- Add body for complex changes

### Branch Naming
- Feature: `feature/description`
- Fix: `fix/description`
- Copilot: `copilot/description` (auto-generated by Copilot)

### Pull Requests
- Target `main` branch
- Provide clear description
- Link related issues
- Ensure CI passes

## Questions or Issues?

- Check `README.md` for comprehensive guide
- Check `features.json` for feature registry documentation
- Run CLI commands with `--help` for detailed usage information

## Remember

1. **Test before committing** - Run relevant test suite
2. **Don't edit auto-generated files** - Edit source CSS/JS files instead
3. **Follow KISS principles** - Keep it simple
4. **Document features** - Update `features.json`
5. **Validate schemas** - Run `python3 test_event_schema.py`
6. **Check accessibility** - Test keyboard navigation and screen readers

## CLI Commands Reference

All commands are run through `src/main.py`:

### Build Commands
- `python3 src/main.py build production` - Build HTML (production mode)
- `python3 src/main.py build development` - Build HTML (development mode with demo events)
- `python3 src/main.py events` - Fast event update (no full rebuild)
- `python3 src/main.py libs` - Download CDN libraries
- `python3 src/main.py libs verify` - Verify libraries are installed

### Event Management
- `python3 src/main.py scrape` - Scrape events from sources
- `python3 src/main.py list` - List published events
- `python3 src/main.py list-pending` - List pending events
- `python3 src/main.py publish EVENT_ID` - Approve a pending event
- `python3 src/main.py reject EVENT_ID` - Reject a pending event
- `python3 src/main.py bulk-publish "pending_*"` - Bulk approve (supports wildcards)
- `python3 src/main.py bulk-reject "pending_*"` - Bulk reject (supports wildcards)

### Utility
- `python3 src/main.py` - Interactive TUI
- `python3 src/main.py --help` - Show all commands
- `python3 src/main.py generate` - Legacy command (uses builder)
