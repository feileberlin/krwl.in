{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "description": "KRWL HOF Feature Registry - Documents all implemented features and how to test them",
  "version": "1.0.0",
  "features": [
    {
      "id": "event-scraping",
      "name": "Event Scraping",
      "description": "Scrape events from RSS feeds, APIs, and HTML pages",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/scraper.py"
      ],
      "config_keys": [
        "scraping.sources",
        "scraping.interval_minutes"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "facebook-flyer-ocr",
      "name": "Facebook Flyer OCR Scraping",
      "description": "Extract event information from Facebook page flyer images using OCR (Optical Character Recognition). Automatically scans posted images for dates, times, event names, and keywords.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/smart_scraper/sources/social/facebook.py",
        "src/modules/smart_scraper/image_analyzer/ocr.py",
        "src/modules/smart_scraper/image_analyzer/analyzer.py"
      ],
      "config_keys": [
        "scraping.sources"
      ],
      "dependencies": {
        "python": [
          "Pillow>=10.0.0",
          "pytesseract>=0.3.10",
          "exifread>=3.0.0"
        ],
        "system": [
          "tesseract-ocr",
          "tesseract-ocr-deu",
          "tesseract-ocr-eng"
        ]
      },
      "test_method": "run_custom_test",
      "test_file": "tests/test_ocr_availability.py",
      "documentation": "README.md section: ðŸ“¸ Facebook Flyer Scraping with OCR"
    },
    {
      "id": "editor-workflow",
      "name": "Editor Workflow",
      "description": "Review, edit, approve, or reject events before publishing",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/editor.py"
      ],
      "config_keys": [
        "editor.require_approval",
        "editor.auto_publish"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "python-tui",
      "name": "Python TUI (Text User Interface)",
      "description": "Interactive terminal interface for managing events with menu navigation",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/event_manager.py"
      ],
      "code_patterns": [
        {
          "file": "src/event_manager.py",
          "pattern": "class EventManagerTUI|def show_menu|input.*Enter your choice",
          "description": "TUI class and menu system"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "cli-commands",
      "name": "CLI Commands",
      "description": "Command-line interface for automation and scripting",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/event_manager.py"
      ],
      "code_patterns": [
        {
          "file": "src/event_manager.py",
          "pattern": "argparse|ArgumentParser|def cli_",
          "description": "CLI argument parsing and command functions"
        },
        {
          "file": "src/event_manager.py",
          "pattern": "def print_help",
          "description": "CLI help documentation"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "interactive-map",
      "name": "Interactive Map",
      "description": "Fullscreen map interface with Leaflet.js showing events",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/html/map-main.html",
        "assets/js/app.js"
      ],
      "code_patterns": [
        {
          "file": "assets/js/map.js",
          "pattern": "L\\.map\\(|class MapManager",
          "description": "Leaflet map initialization in MapManager class"
        },
        {
          "file": "assets/html/map-main.html",
          "pattern": "id=\"map\"",
          "description": "Map container element"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "geolocation-filtering",
      "name": "Geolocation Filtering",
      "description": "Shows only events near the user's location",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js"
      ],
      "config_keys": [
        "filtering.max_distance_km"
      ],
      "code_patterns": [
        {
          "file": "assets/js/map.js",
          "pattern": "navigator.geolocation.getCurrentPosition|getUserLocation",
          "description": "Geolocation API usage"
        },
        {
          "file": "assets/js/filters.js",
          "pattern": "calculateDistance",
          "description": "Distance calculation function"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "sunrise-filtering",
      "name": "Sunrise Filtering",
      "description": "Displays events only until the next sunrise",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js"
      ],
      "config_keys": [
        "filtering.show_until"
      ],
      "code_patterns": [
        {
          "file": "assets/js/app.js",
          "pattern": "getNextSunrise|sunrise",
          "description": "Sunrise calculation or filtering"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "extended-time-filters",
      "name": "Extended Time Filter Options",
      "description": "Additional time filter options including Sunday primetime (20:15) and full moon timing. Provides more flexible event filtering beyond basic time ranges.",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js"
      ],
      "code_patterns": [
        {
          "file": "assets/js/subjective-day.js",
          "pattern": "getEndOfSubjectiveDay|getSunrise|getSunset",
          "description": "Subjective day time calculations"
        },
        {
          "file": "assets/js/filters.js",
          "pattern": "EventFilter|filterEvents",
          "description": "Event filter class"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "static-site-generation",
      "name": "Static Site Generation (CDN Inliner)",
      "description": "Generates single-file static HTML with all resources inlined from CDN or local fallback",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/site_generator.py"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "debug-mode",
      "name": "Debug Mode",
      "description": "Debug mode with console logging for troubleshooting. Automatically enabled in development environment.",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js",
        "config.json",
        "src/modules/utils.py"
      ],
      "config_keys": [],
      "code_patterns": [
        {
          "file": "assets/js/app.js",
          "pattern": "this.log|\\[KRWL Debug\\]",
          "description": "Debug logging implementation"
        },
        {
          "file": "config.json",
          "pattern": "_comment_hardcoded.*debug",
          "description": "Debug mode auto-detected (documented in config)"
        },
        {
          "file": "src/modules/utils.py",
          "pattern": "config\\['debug'\\]|debug.*=.*True|debug.*=.*False",
          "description": "Debug flag set in utils.py based on environment"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "production-optimization",
      "name": "Production Optimization",
      "description": "Production-optimized config with caching. Automatically enabled in CI/production.",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js",
        "config.json",
        "src/modules/utils.py"
      ],
      "config_keys": [],
      "code_patterns": [
        {
          "file": "config.json",
          "pattern": "_comment_hardcoded.*cache|_comment_hardcoded.*prefetch",
          "description": "Caching auto-detected (documented in config)"
        },
        {
          "file": "src/modules/utils.py",
          "pattern": "cache_enabled|prefetch_events",
          "description": "Performance flags set in utils.py based on environment"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "preview-deployment",
      "name": "Preview Deployment",
      "description": "Deploy testing/preview version with debug mode",
      "category": "deployment",
      "implemented": false,
      "files": [
        ".github/workflows/deploy-preview.yml"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "production-deployment",
      "name": "Production Deployment",
      "description": "Deploy production version to main branch",
      "category": "deployment",
      "implemented": false,
      "files": [
        ".github/workflows/deploy-pages.yml"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "promotion-workflow",
      "name": "Promotion Workflow",
      "description": "Promote preview to production via PR",
      "category": "deployment",
      "implemented": false,
      "files": [
        ".github/workflows/promote-preview.yml"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "demo-events",
      "name": "Demo Events Generation",
      "description": "Generate demo events with current timestamps for testing",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/tools/generate_demo_events.py"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "multi-data-sources",
      "name": "Multiple Data Sources",
      "description": "Support for real, demo, or combined event data sources",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js",
        "config.json",
        "src/modules/utils.py"
      ],
      "config_keys": [
        "data.sources"
      ],
      "code_patterns": [
        {
          "file": "assets/js/app.js",
          "pattern": "loadEvents|this\\.events",
          "description": "Event loading functionality"
        },
        {
          "file": "config.json",
          "pattern": "data.*source",
          "description": "Data source configuration"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "custom-domain-support",
      "name": "Custom Domain Support",
      "description": "Support for custom domains via CNAME",
      "category": "deployment",
      "implemented": false,
      "files": [
        "CNAME",
        ".github/workflows/deploy-pages.yml"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "event-filters",
      "name": "Event Filters",
      "description": "Filter events by category, time, and distance",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js",
        "assets/html/filter-nav.html"
      ],
      "code_patterns": [
        {
          "file": "assets/js/app.js",
          "pattern": "filterEvents|applyFilters",
          "description": "Event filtering logic"
        },
        {
          "file": "assets/html/filter-nav.html",
          "pattern": "event-filter-bar|filter-bar-time-range|filter-bar-distance|filter-bar-location",
          "description": "Filter UI elements"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "backup-system",
      "name": "Data Backup System",
      "description": "Automatic backups when clearing data with .backup extension",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/event_manager.py"
      ],
      "code_patterns": [
        {
          "file": "src/event_manager.py",
          "pattern": "\\.backup|shutil.copy.*backup",
          "description": "Backup file creation"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "custom-location",
      "name": "Custom Location Override with localStorage Persistence",
      "description": "Allow users to set custom location instead of using geolocation. Custom coordinates persist in browser localStorage across sessions and location type switches.",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js",
        "assets/html/filter-nav.html"
      ],
      "code_patterns": [
        {
          "file": "assets/js/app.js",
          "pattern": "useCustomLocation|custom-location|customLat|customLon|saveFiltersToCookie|loadFiltersFromCookie",
          "description": "Custom location functionality with localStorage persistence"
        },
        {
          "file": "assets/html/filter-nav.html",
          "pattern": "filter-bar-location",
          "description": "Custom location UI elements"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "documentation-viewer",
      "name": "Built-in Documentation Viewer",
      "description": "CLI-based documentation viewer with task runner",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/event_manager.py",
        "src/modules/docs_runner.py"
      ],
      "code_patterns": [
        {
          "file": "src/event_manager.py",
          "pattern": "command == 'docs'|DocsRunner",
          "description": "Documentation CLI command"
        },
        {
          "file": "src/modules/docs_runner.py",
          "pattern": "class DocsRunner|list_tasks|run_task",
          "description": "Documentation runner implementation"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "example-data-loader",
      "name": "Example Data Loader",
      "description": "Load example/sample data for development and testing",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/event_manager.py"
      ],
      "code_patterns": [
        {
          "file": "src/event_manager.py",
          "pattern": "def load_example_data|cli_load_examples|events_example",
          "description": "Example data loading functionality"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "data-management",
      "name": "Data Management Tools",
      "description": "CLI and TUI tools to clear, list, and manage event data",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/event_manager.py"
      ],
      "code_patterns": [
        {
          "file": "src/event_manager.py",
          "pattern": "def clear_all_data|cli_clear_data|cli_list",
          "description": "Data management commands"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "event-cards",
      "name": "Event Card UI",
      "description": "Card-based UI for displaying event details in the sidebar",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/speech-bubbles.js",
        "assets/css/bubbles.css",
        "assets/html/map-main.html"
      ],
      "code_patterns": [
        {
          "file": "assets/js/speech-bubbles.js",
          "pattern": "class SpeechBubbles|showEventDetail|createBubbleHTML",
          "description": "Event display in speech bubbles"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "map-markers",
      "name": "Map Markers",
      "description": "Interactive markers on the map for events and user location",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js"
      ],
      "code_patterns": [
        {
          "file": "assets/js/map.js",
          "pattern": "L\\.marker|addEventMarker|createMarkerIcon",
          "description": "Leaflet marker management in MapManager"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "distance-calculation",
      "name": "Distance Calculation",
      "description": "Haversine formula distance calculation between coordinates",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/utils.py",
        "assets/js/app.js"
      ],
      "code_patterns": [
        {
          "file": "src/modules/utils.py",
          "pattern": "def calculate_distance|Haversine",
          "description": "Distance calculation in Python"
        },
        {
          "file": "assets/js/filters.js",
          "pattern": "calculateDistance",
          "description": "Distance calculation in JavaScript"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "responsive-design",
      "name": "Responsive Design",
      "description": "Mobile-responsive layout with CSS media queries",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/css/style.css",
        "assets/css/mobile.css",
        "assets/html/html-head.html"
      ],
      "code_patterns": [
        {
          "file": "assets/css/style.css",
          "pattern": "@media.*max-width|viewport",
          "description": "Responsive CSS media queries"
        },
        {
          "file": "assets/html/html-head.html",
          "pattern": "viewport.*width=device-width",
          "description": "Viewport meta tag in head component"
        }
      ],
      "test_method": "check_code_patterns"
    },
    {
      "id": "workflow-launcher",
      "name": "GitHub Actions Workflow Launcher",
      "description": "Launch and manage GitHub Actions workflows using GitHub CLI. Integrated into event_manager.py main CLI with 'workflow' command for unified management. View workflow runs with dispatch options displayed in the status overview. Shows which inputs were selected when manually triggering workflows via workflow_dispatch.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/workflow_launcher.py",
        "src/event_manager.py",
        "tests/test_workflow_inputs.py"
      ],
      "code_patterns": [
        {
          "file": "src/modules/workflow_launcher.py",
          "pattern": "class WorkflowLauncher|def trigger_workflow|def get_workflow_run_inputs|gh workflow run",
          "description": "Workflow launcher class with dispatch options display"
        },
        {
          "file": "src/event_manager.py",
          "pattern": "def cli_workflow|command == 'workflow'",
          "description": "CLI integration for workflow commands"
        }
      ],
      "test_method": "run_custom_test",
      "test_file": "tests/test_workflow_inputs.py",
      "test_instructions": "1. Run workflow input tests: python3 tests/test_workflow_inputs.py\n2. View demo: python3 examples/demo_workflow_inputs.py\n3. List workflows: python3 src/event_manager.py workflow list\n4. Check status (requires gh auth): python3 src/event_manager.py workflow status scrape-events\n5. Trigger workflow: python3 src/event_manager.py workflow run scrape-events --branch preview --input force_deploy=true\n6. Verify help text: python3 src/event_manager.py --help | grep workflow"
    },
    {
      "id": "copilot-custom-instructions",
      "name": "GitHub Copilot Custom Instructions",
      "description": "Comprehensive project-specific instructions for GitHub Copilot including architecture, coding guidelines, and workflows",
      "category": "infrastructure",
      "implemented": true,
      "files": [
        ".github/copilot-instructions.md",
        ".github/pull_request_template.md"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "vscode-workspace-config",
      "name": "VS Code Workspace Configuration",
      "description": "Workspace settings, recommended extensions, tasks, and debug configurations for VS Code",
      "category": "infrastructure",
      "implemented": true,
      "files": [
        ".vscode/settings.json",
        ".vscode/extensions.json",
        ".vscode/tasks.json",
        ".vscode/launch.json"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "devcontainer-config",
      "name": "Development Container Configuration",
      "description": "Docker-based development container with Python 3.11, pre-configured tools, and automatic dependency installation",
      "category": "infrastructure",
      "implemented": true,
      "files": [
        ".devcontainer/devcontainer.json"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "mcp-server-config",
      "name": "Model Context Protocol (MCP) Server Configuration",
      "description": "MCP server configuration for GitHub, filesystem, and memory context to enhance AI assistance",
      "category": "infrastructure",
      "implemented": true,
      "files": [
        ".github/mcp/servers.json",
        ".github/mcp/README.md"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "dev-environment-docs",
      "name": "Development Environment Documentation",
      "description": "Comprehensive documentation for development environment setup including VS Code, devcontainer, and MCP configuration",
      "category": "infrastructure",
      "implemented": true,
      "files": [
        "README.md"
      ],
      "test_method": "check_files_exist"
    },
    {
      "id": "dashboard-menu",
      "name": "Dashboard Menu with Project Information",
      "description": "Clickable logo opens dashboard menu showing About, Debug Info, Maintainer, Documentation links, and Credits. Replaces watermark functionality with better UX. Mobile-first responsive design with keyboard accessibility.",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/html/dashboard-aside.html",
        "assets/css/style.css",
        "assets/js/app.js",
        "config.json",
        "src/modules/utils.py"
      ],
      "config_keys": [
        "app.environment"
      ],
      "code_patterns": [
        {
          "file": "assets/js/app.js",
          "pattern": "updateDashboard|dashboard-menu|dashboardLogo",
          "description": "Dashboard update function and menu toggle logic"
        },
        {
          "file": "assets/css/style.css",
          "pattern": "#dashboard-menu|.dashboard-content",
          "description": "Dashboard CSS styles"
        },
        {
          "file": "assets/html/dashboard-aside.html",
          "pattern": "dashboard-menu|dashboard-content|close-dashboard",
          "description": "Dashboard HTML structure"
        },
        {
          "file": "config.json",
          "pattern": "_comment_hardcoded.*watermark|_comment_hardcoded.*debug|_comment_hardcoded.*data.source",
          "description": "Environment-dependent values documented in config"
        }
      ],
      "test_method": "automated",
      "test_file": "tests/test_watermark_simplification.py",
      "test_instructions": "Run: python3 tests/test_watermark_simplification.py"
    },
    {
      "id": "environment-watermark",
      "name": "Environment Watermark (REPLACED by dashboard-menu)",
      "description": "DEPRECATED: This feature has been replaced by the dashboard menu. The watermark has been removed from the UI. Environment and debug information is now shown in the dashboard menu accessible by clicking the logo.",
      "category": "frontend",
      "implemented": false,
      "deprecated": true,
      "replaced_by": "dashboard-menu",
      "files": [],
      "config_keys": [
        "watermark.text"
      ],
      "code_patterns": [],
      "test_method": "none",
      "test_instructions": "This feature has been replaced by dashboard-menu. See dashboard-menu for testing."
    },
    {
      "id": "github-environments",
      "name": "GitHub Environments UI Integration",
      "description": "Configure GitHub Actions workflows to use environments, making deployments visible in GitHub UI with direct links to preview and production sites",
      "category": "infrastructure",
      "implemented": false,
      "files": [
        ".github/workflows/deploy-pages.yml",
        ".github/workflows/deploy-preview.yml"
      ],
      "config_keys": [],
      "code_patterns": [
        {
          "file": ".github/workflows/deploy-pages.yml",
          "pattern": "environment:\\s+name: production",
          "description": "Production environment configuration"
        },
        {
          "file": ".github/workflows/deploy-preview.yml",
          "pattern": "environment:\\s+name: preview",
          "description": "Preview environment configuration"
        }
      ],
      "test_method": "manual",
      "test_instructions": "1. Navigate to GitHub repository\n2. Click 'Environments' in sidebar\n3. Verify 'production' and 'preview' environments are listed\n4. Click on environment to see deployment history\n5. Click 'View deployment' button to open deployed site"
    },
    {
      "id": "time-drawer",
      "name": "Dynamic Time-Based Marker Resizing",
      "description": "[PLANNED] Interactive timeline drawer with dynamic marker scaling based on event proximity to selected time. Files not yet created.",
      "category": "frontend",
      "implemented": false,
      "files": [
        "assets/js/time-drawer.js",
        "assets/css/time-drawer.css",
        "assets/js/app.js",
        "src/modules/site_generator.py"
      ],
      "code_patterns": [
        {
          "file": "assets/js/time-drawer.js",
          "pattern": "class TimeDrawer|calculateMarkerScale|applyMarkerScale",
          "description": "TimeDrawer class with marker scaling logic"
        },
        {
          "file": "assets/js/app.js",
          "pattern": "this.timeDrawer|new TimeDrawer|registerMarker",
          "description": "TimeDrawer integration in EventsApp"
        },
        {
          "file": "assets/css/time-drawer.css",
          "pattern": ".time-drawer|.time-drawer-handle|.time-drawer-progress",
          "description": "Time drawer styling"
        }
      ],
      "test_method": "manual",
      "test_instructions": "1. Open the app with 5+ events\n2. Set filter to 'til sunrise'\n3. Verify time drawer appears at bottom\n4. Drag the handle left/right\n5. Verify markers scale dynamically (70%-130%)\n6. Verify largest markers have glow effect\n7. Try with < 5 events - drawer should show threshold message\n8. Change filter to '6h' - drawer should disappear\n9. Test on mobile - touch gestures should work"
    },
    {
      "id": "keyboard-navigation",
      "name": "Keyboard Navigation",
      "description": "Full keyboard controls for map navigation and event browsing - ESC to close popups, arrow keys to navigate events, +/- to zoom",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js"
      ],
      "code_patterns": [
        {
          "file": "assets/js/app.js",
          "pattern": "currentEventIndex|navigateEvents|keydown.*Escape|keydown.*Arrow",
          "description": "Keyboard event handling and navigation logic"
        }
      ],
      "test_method": "manual",
      "test_instructions": "1. Open the app and click on an event to view details\n2. Press ESC - detail popup should close\n3. Open an event detail again\n4. Press Right Arrow - should navigate to next event (sorted by time)\n5. Press Left Arrow - should navigate to previous event\n6. Navigate past the last event - should wrap to first event\n7. Press + or = key - map should zoom in\n8. Press - or _ key - map should zoom out\n9. Test that map centers on events during arrow navigation\n10. Open filter dropdown and press ESC - dropdown should close"
    },
    {
      "id": "app-ready-signal",
      "name": "App Ready Signal for Screenshots",
      "description": "Emits a ready signal when the app is fully initialized (config loaded, map initialized, events loaded). Enables reliable screenshot generation by providing a data-app-ready attribute and custom event",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/app.js",
        "src/tools/generate_screenshots.py",
        "README.md"
      ],
      "code_patterns": [
        {
          "file": "assets/js/app.js",
          "pattern": "markAppAsReady|data-app-ready|app-ready.*CustomEvent",
          "description": "App ready signal implementation and emission"
        }
      ],
      "test_method": "automated",
      "test_instructions": "1. Start local server: cd static && python3 -m http.server 8000\n2. Run test script: python3 src/tools/generate_screenshots.py --verbose\n3. Verify body[data-app-ready='true'] attribute is set after page load\n4. Verify 'app-ready' custom event is dispatched with event.detail metadata\n5. Check that screenshots are captured with fully loaded map and events\n6. Verify both mobile (640Ã—1136) and desktop (1280Ã—800) screenshots are generated"
    },
    {
      "id": "html-export-linting",
      "name": "HTML Export Linting",
      "description": "Comprehensive linting of exported HTML, including JavaScript, CSS, HTML structure, SVG content, translations, and accessibility (a11y) checks during site generation",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/linter.py",
        "src/modules/site_generator.py",
        "tests/test_linter.py"
      ],
      "code_patterns": [
        {
          "file": "src/modules/linter.py",
          "pattern": "class Linter|lint_javascript|lint_css|lint_html|lint_svg|lint_translations|lint_accessibility",
          "description": "Linter implementation with multiple validation methods"
        },
        {
          "file": "src/modules/site_generator.py",
          "pattern": "from.*linter import Linter|linter.lint_all",
          "description": "Integration of linter into site generation process"
        }
      ],
      "test_method": "automated",
      "test_instructions": "1. Run unit tests: python3 tests/test_linter.py --verbose\n2. Generate site: python3 src/event_manager.py generate\n3. Verify linting output shows validation of:\n   - JavaScript (checks for eval(), console.log, bracket matching)\n   - CSS (checks for bracket matching, !important overuse)\n   - HTML (checks for doctype, lang attribute, required tags)\n   - SVG (checks for script tags, event handlers, security issues)\n   - Translations (checks for completeness, consistency between languages)\n   - Accessibility (checks for WCAG 2.1 Level AA compliance)\n4. Confirm build completes even with lint warnings (non-blocking)\n5. Review lint report for actionable issues"
    },
    {
      "id": "markdown-html-builder",
      "name": "Markdown to HTML Documentation Builder",
      "description": "Automated build system that converts all Markdown documentation to styled HTML with GitHub-style dark theme and Barbie Pink accents. Part of htmldocs_generator module.",
      "category": "infrastructure",
      "implemented": true,
      "files": [
        "src/modules/htmldocs_generator.py",
        "src/tools/cleanup_old_docs.py",
        "scripts/README.md",
        "requirements.txt"
      ],
      "code_patterns": [
        {
          "file": "src/modules/htmldocs_generator.py",
          "pattern": "def convert_markdown_to_html|def generate_docs_index|def organize_files|markdown.Markdown",
          "description": "Core conversion and organization functions"
        },
        {
          "file": "src/modules/htmldocs_generator.py",
          "pattern": "Barbie Pink|color-primary|bg-primary|text-primary",
          "description": "Uses design tokens from config.json for theming"
        }
      ],
      "config_keys": [],
      "test_method": "manual",
      "test_instructions": "1. Install dependencies: pip install markdown>=3.5.0 Pygments>=2.17.0\n2. Build documentation: python3 src/event_manager.py docs build\n3. Verify all .md files converted to .html with:\n   - GitHub dark theme (#0d1117 background, #c9d1d9 text)\n   - Barbie Pink (#FF69B4) headings and accents\n   - Syntax highlighting in code blocks\n   - Navigation bar on every page\n4. Verify file organization in docs/\n5. Verify docs/index.html generated with categorized navigation\n6. Test cleanup script: python3 src/tools/cleanup_old_docs.py --dry-run\n7. Open docs/index.html in browser and verify it works with file:// protocol"
    },
    {
      "id": "pydantic-validation",
      "name": "Pydantic Data Validation",
      "description": "Type-safe data validation using Pydantic models for events, locations, and configuration. Ensures data integrity throughout the pipeline with automatic validation and helpful error messages.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/models.py",
        "src/modules/scraper.py",
        "src/modules/editor.py",
        "src/modules/utils.py"
      ],
      "code_patterns": [
        {
          "file": "src/modules/models.py",
          "pattern": "class Event\\(BaseModel\\)|class Location\\(BaseModel\\)|@field_validator|validate_event_data",
          "description": "Pydantic models with field validators"
        }
      ],
      "test_method": "automated",
      "test_instructions": "Run: python3 tests/test_validation.py --verbose"
    },
    {
      "id": "error-handling-retry-logic",
      "name": "Robust Error Handling and Retry Logic",
      "description": "Graceful error handling with custom exceptions, exponential backoff retry logic for network requests, and source-level failure isolation. One failing source doesn't crash the entire scraping process.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/exceptions.py",
        "src/modules/scraper.py"
      ],
      "code_patterns": [
        {
          "file": "src/modules/exceptions.py",
          "pattern": "class ScraperError|class NetworkError|class SourceUnavailableError|class ParsingError",
          "description": "Custom exception hierarchy"
        },
        {
          "file": "src/modules/scraper.py",
          "pattern": "@retry|make_retry_decorator|stop_after_attempt|wait_exponential",
          "description": "Retry logic with exponential backoff using tenacity"
        }
      ],
      "test_method": "integration",
      "test_instructions": "1. Run scraper with one invalid source: python3 src/event_manager.py scrape\n2. Verify scraper continues despite source failure\n3. Check logs for retry attempts and error details\n4. Verify _write_scrape_status includes error summary"
    },
    {
      "id": "structured-logging",
      "name": "Structured Logging System",
      "description": "Centralized logging configuration with appropriate log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL), structured context data, and separate configurations for CLI and TUI modes. Includes rotating file handlers for production debugging.",
      "category": "infrastructure",
      "implemented": true,
      "files": [
        "src/modules/logging_config.py",
        "src/event_manager.py",
        "src/modules/scraper.py",
        "src/modules/editor.py",
        "src/modules/utils.py"
      ],
      "code_patterns": [
        {
          "file": "src/modules/logging_config.py",
          "pattern": "def setup_logging|configure_for_cli|configure_for_tui|RotatingFileHandler",
          "description": "Logging configuration functions"
        },
        {
          "file": "src/modules/scraper.py",
          "pattern": "logger = logging.getLogger|logger.info|logger.error|logger.warning|extra=",
          "description": "Structured logging with context"
        }
      ],
      "test_method": "manual",
      "test_instructions": "1. Run CLI with debug: python3 src/event_manager.py scrape --debug\n2. Verify DEBUG level logs appear\n3. Run TUI: python3 src/event_manager.py\n4. Verify logs written to logs/event_manager.log\n5. Check log rotation works (max 5MB per file)"
    },
    {
      "id": "configuration-validation",
      "name": "Configuration Validation",
      "description": "Validates config.json structure and values on load, including URLs, coordinates, and required fields. Provides helpful error messages with specific field names and expected values.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/utils.py"
      ],
      "code_patterns": [
        {
          "file": "src/modules/utils.py",
          "pattern": "def validate_config|ConfigurationError|validate_config\\(config\\)",
          "description": "Configuration validation function"
        }
      ],
      "test_method": "manual",
      "test_instructions": "1. Temporarily break config.json (invalid lat/lon, missing field)\n2. Run: python3 src/event_manager.py list\n3. Verify helpful ConfigurationError with field name\n4. Restore config.json"
    },
    {
      "id": "styled-html-docs",
      "name": "Styled HTML Documentation",
      "description": "HTML documentation viewer with Barbie Pink theme and emoji icons, auto-generated from Markdown",
      "category": "infrastructure",
      "implemented": true,
      "files": [
        "src/modules/htmldocs_generator.py",
        "src/modules/docs_runner.py",
        "public/docs/"
      ],
      "config_keys": [
        "design.colors",
        "design.typography",
        "design.spacing"
      ],
      "test_method": "check_files_exist",
      "cli_command": "python3 src/event_manager.py docs html-docs"
    },
    {
      "id": "unified-workflow-wrapper",
      "name": "Unified Workflow Wrapper (Adaptive)",
      "description": "[DEPRECATED] Single GitHub Actions workflow that automatically adapts to changes. This concept was replaced by split workflows: scheduled-scraping.yml, deploy.yml, editorial-workflow.yml, monthly-archive.yml, maintenance.yml.",
      "category": "infrastructure",
      "implemented": false,
      "files": [
        ".github/workflows/scheduled-scraping.yml",
        ".github/workflows/deploy.yml",
        ".github/workflows/editorial-workflow.yml",
        ".github/workflows/monthly-archive.yml",
        ".github/workflows/maintenance.yml",
        "src/modules/scraper.py",
        "src/event_manager.py"
      ],
      "config_keys": [
        "scraping.sources",
        "scraping.schedule.timezone",
        "scraping.schedule.times"
      ],
      "code_patterns": [
        {
          "file": "src/modules/scraper.py",
          "pattern": "get_scraper_capabilities|get_enabled_sources|get_scraping_schedule",
          "description": "Scraper introspection methods for workflow adaptation"
        },
        {
          "file": "src/event_manager.py",
          "pattern": "scraper-info|bulk-publish|bulk-reject",
          "description": "CLI commands for workflow integration"
        }
      ],
      "test_method": "manual",
      "test_instructions": "[DEPRECATED - This feature is no longer implemented]\n\nThe unified workflow was replaced by split workflows:\n- scheduled-scraping.yml (event/weather scraping)\n- deploy.yml (deployment)\n- editorial-workflow.yml (editorial review)\n- monthly-archive.yml (archiving)\n- maintenance.yml (manual maintenance)\n\nTo validate, check each workflow exists:\npython3 -c \"import os; print(all(os.path.exists(f'.github/workflows/{w}') for w in ['scheduled-scraping.yml', 'deploy.yml', 'editorial-workflow.yml', 'monthly-archive.yml', 'maintenance.yml']))\"",
      "cli_command": "python3 src/event_manager.py scraper-info"
    },
    {
      "id": "event-archiving",
      "name": "Configurable Monthly Event Archiving",
      "description": "Automatically archive old events based on configurable retention window (default: 60 days). Events are organized by month into archive files (e.g., 202601.json) to keep the active events list manageable and improve performance. Configuration is entirely in config.json with GitHub Actions integration via unified website-maintenance workflow.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/archive_events.py",
        "src/event_manager.py",
        ".github/workflows/monthly-archive.yml",
        "tests/test_archive_events.py"
      ],
      "config_keys": [
        "archiving.enabled",
        "archiving.schedule.day_of_month",
        "archiving.schedule.time",
        "archiving.schedule.timezone",
        "archiving.retention.active_window_days",
        "archiving.organization.format",
        "archiving.organization.path"
      ],
      "code_patterns": [
        {
          "file": "src/modules/archive_events.py",
          "pattern": "class EventArchiver|def archive_events|def _get_archive_filename",
          "description": "Archiver class with configurable retention and organization"
        },
        {
          "file": "src/event_manager.py",
          "pattern": "cli_archive_monthly|cli_archive_info|archive-monthly|archive-info",
          "description": "CLI commands for archiving and configuration display"
        },
        {
          "file": ".github/workflows/monthly-archive.yml",
          "pattern": "archive-monthly|Archive Old Events",
          "description": "Monthly archiving job in dedicated workflow"
        }
      ],
      "test_method": "automated",
      "test_file": "tests/test_archive_events.py",
      "test_instructions": "1. Run archiving tests: python3 tests/test_archive_events.py\n2. Test dry-run: python3 src/event_manager.py archive-monthly --dry-run\n3. View configuration: python3 src/event_manager.py archive-info\n4. Test with different retention: Edit config.json â†’ archiving.retention.active_window_days\n5. Verify archives created: Check assets/json/events/archived/ directory\n6. Test GitHub Actions: Trigger \"ðŸ“¦ Monthly Event Archiving\" workflow (monthly-archive.yml)",
      "cli_command": "python3 src/event_manager.py archive-monthly --dry-run"
    },
    {
      "id": "responsive-viewport-system",
      "name": "Responsive Viewport System for Multi-Layer Architecture",
      "description": "CSS custom properties (--app-width, --app-height) with progressive enhancement that ensures all fixed-position layers scale consistently with the base map layer. Handles mobile browser address bars, orientation changes, and keyboard appearance. Includes JavaScript enhancement for pixel-perfect dimensions.",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/css/base.css",
        "assets/css/map.css",
        "assets/css/filters.css",
        "assets/css/style.css",
        "assets/css/scrollbar.css",
        "assets/js/app.js"
      ],
      "config_keys": [],
      "code_patterns": [
        {
          "file": "assets/css/base.css",
          "pattern": "--app-width|--app-height|100dvh|100dvw",
          "description": "CSS custom properties for viewport dimensions with progressive enhancement"
        },
        {
          "file": "assets/css/map.css",
          "pattern": "var\\(--app|height:.*100",
          "description": "Map layer uses CSS custom properties or full viewport"
        }
      ],
      "test_method": "manual",
      "test_instructions": "1. Open app in browser\n2. Verify no hardcoded 100vh/100vw in layers: grep -r '100vh\\|100vw' assets/css/*.css\n3. Test mobile: Open DevTools â†’ Mobile view â†’ Toggle device toolbar\n4. Test orientation: Rotate device/emulator from portrait to landscape\n5. Test address bar: Scroll on mobile to hide/show address bar\n6. Verify CSS variables: Open DevTools â†’ Elements â†’ :root â†’ Check --app-width and --app-height\n7. Test resize: Resize browser window and verify all layers scale together\n8. Test keyboard: On mobile, focus input field to show keyboard, verify layers adjust\n9. Architecture analysis: Read docs/LAYER_ARCHITECTURE_ANALYSIS.md for design rationale"
    },
    {
      "id": "weather-dresscode",
      "name": "Weather Dresscode Display",
      "description": "Scrape current weather conditions from MSN Weather and display dresscode recommendations in filter bar with format 'with [dresscode].' (e.g., 'with warm pullover.'). Weather data is embedded in APP_CONFIG.weather.data. Validates dresscodes against accepted list. Hourly caching prevents excessive requests. Weather scraping runs via scheduled-scraping.yml workflow.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/weather_scraper.py",
        "src/modules/site_generator.py",
        "assets/json/weather_dresscodes.json",
        "assets/html/filter-nav.html",
        "assets/js/app.js",
        "assets/css/style.css",
        ".github/workflows/scheduled-scraping.yml"
      ],
      "config_keys": [
        "weather.enabled",
        "weather.cache_hours",
        "weather.locations",
        "weather.display.show_in_filter_bar"
      ],
      "code_patterns": [
        {
          "file": "src/modules/weather_scraper.py",
          "pattern": "class WeatherScraper|_extract_dresscode|_validate_dresscode",
          "description": "Weather scraper with dresscode extraction and validation"
        },
        {
          "file": "assets/js/app.js",
          "pattern": "loadWeather|displayWeatherDresscode|window.WEATHER_CACHE",
          "description": "Frontend weather loading from inlined cache"
        },
        {
          "file": "assets/html/filter-nav.html",
          "pattern": "filter-bar-weather|weather-chip",
          "description": "Weather chip in filter bar"
        },
        {
          "file": "src/modules/site_generator.py",
          "pattern": "load_weather_cache|window.WEATHER_CACHE",
          "description": "Weather cache inlined in HTML"
        },
        {
          "file": ".github/workflows/scheduled-scraping.yml",
          "pattern": "Scrape Weather|scrape-weather",
          "description": "GitHub Actions workflow for weather scraping"
        }
      ],
      "test_method": "check_code_patterns",
      "test_instructions": "1. Run weather scraper: python3 src/event_manager.py scrape-weather\n2. Verify cache created: assets/json/weather_cache.json\n3. Check dresscode is validated against accepted list\n4. Generate site: python3 src/event_manager.py generate\n5. Verify APP_CONFIG.weather.data is embedded in public/index.html\n6. Open site and verify weather chip appears at end of filter bar\n7. Verify dresscode text is displayed in format 'with [dresscode].' (e.g., 'with warm pullover.')\n8. Hover over chip to see temperature tooltip (e.g., '8Â°C â€¢ with warm pullover.')\n9. Test hourly caching: run scrape-weather again within 1 hour, should use cache\n10. Force refresh: python3 src/event_manager.py scrape-weather --force\n11. Test GitHub Actions: Trigger \"ðŸ¤– Scheduled Event & Weather Scraping\" workflow (scheduled-scraping.yml)"
    },
    {
      "id": "draggable-speech-bubbles",
      "name": "Draggable Speech Bubbles",
      "description": "Speech bubbles (event info cards) can be dragged by the user to manually resolve any positioning conflicts. Supports both mouse and touch gestures. User-positioned bubbles maintain their relative offset from the marker when the map is panned or zoomed.",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/js/speech-bubbles.js",
        "assets/css/style.css"
      ],
      "code_patterns": [
        {
          "file": "assets/js/speech-bubbles.js",
          "pattern": "handleDragStart|handleDragMove|handleDragEnd|userOffset",
          "description": "Drag event handlers and user offset tracking"
        },
        {
          "file": "assets/css/bubbles.css",
          "pattern": "speech-bubble.*grab|dragging",
          "description": "Drag cursor and dragging state styles"
        }
      ],
      "test_method": "manual",
      "test_instructions": "1. Open the app with events displayed\n2. Verify bubbles show cursor: grab on hover\n3. Click and drag a bubble - it should move freely\n4. Verify bubble shows elevated style while dragging (scale, shadow)\n5. Release the bubble - it should stay at new position\n6. Pan or zoom the map - dragged bubble should maintain relative position to its marker\n7. Test on mobile: touch and drag should work\n8. Verify map panning is disabled while dragging bubble\n9. Verify clicking bookmark button inside bubble does not trigger drag"
    },
    {
      "id": "ai-categorization",
      "name": "AI-Powered Event Categorization",
      "description": "[PLANNED] AI-powered event categorization using local LLM (Ollama). Infrastructure exists but integration in scraper not complete.",
      "category": "backend",
      "implemented": false,
      "files": [
        "src/modules/ai_categorizer.py",
        "src/modules/smart_scraper/ai_providers/ollama.py",
        "src/modules/event_schema.py",
        "src/modules/scraper.py"
      ],
      "config_keys": [
        "ai.categorization.enabled",
        "ai.ollama.host",
        "ai.ollama.model",
        "ai.ollama.timeout"
      ],
      "code_patterns": [
        {
          "file": "src/modules/ai_categorizer.py",
          "pattern": "class AICategorizer|categorize_event",
          "description": "Main AI categorization logic"
        }
      ],
      "test_method": "check_code_patterns",
      "test_instructions": "1. Run AI categorization tests: python3 tests/test_ai_categorization.py\n2. Test keyword fallback (no Ollama): All 7 test events should categorize correctly\n3. Optional AI test (requires Ollama):\n   a. Install Ollama: https://ollama.ai/\n   b. Run: ollama pull llama3.2\n   c. Start Ollama service\n   d. Enable in config.json: ai.categorization.enabled = true\n   e. Run scraper: python3 src/event_manager.py scrape\n   f. Verify events get categorized (check logs for 'AI categorized')\n4. Test status: python3 -c 'from modules.ai_categorizer import *; from modules.utils import *; c = AICategorizer(load_config(Path(\".\")), Path(\".\")); print(c.get_status())'\n5. Verify fallback works if Ollama unavailable"
    },
    {
      "id": "ai-event-extraction",
      "name": "Local AI Event Extraction",
      "description": "Aggregates post text, OCR output, and image metadata into a local LLM prompt to extract event details (title, times, URL, location). Uses only local providers (Ollama/local_llm) and enriches social scraping when available.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/smart_scraper/ai_event_extractor.py",
        "src/modules/smart_scraper/ai_providers/local_llm.py",
        "src/modules/smart_scraper/sources/social/facebook.py"
      ],
      "config_keys": [
        "ai.ollama.host",
        "ai.ollama.model",
        "ai.ollama.timeout"
      ],
      "code_patterns": [
        {
          "file": "src/modules/smart_scraper/ai_event_extractor.py",
          "pattern": "class LocalEventExtractor|build_context|extract_event_details",
          "description": "Aggregates context and extracts event details via local AI"
        },
        {
          "file": "src/modules/smart_scraper/ai_providers/local_llm.py",
          "pattern": "class LocalLLMProvider|_build_event_extraction_prompt",
          "description": "Local LLM provider with extraction prompt"
        },
        {
          "file": "src/modules/smart_scraper/sources/social/facebook.py",
          "pattern": "event_extractor|_ai_extract_event_details|ai_details",
          "description": "Facebook scraper AI enrichment path"
        }
      ],
      "test_method": "check_code_patterns",
      "test_instructions": "1. Run AI extraction tests: python3 tests/test_ai_event_extraction.py\n2. Optional: run smart scraper tests: python3 tests/test_smart_scraper.py\n3. With Ollama running, scrape a Facebook source and confirm AI-enriched fields populate"
    },
    {
      "id": "location-resolver",
      "name": "Location Resolution",
      "description": "Resolves generic location names (e.g., \"Hof\", \"Frankenpost\") to specific venue names by scraping event detail pages",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/location_resolver.py"
      ],
      "config_keys": [],
      "test_method": "check_files_exist",
      "cli_commands": [
        "resolve-locations",
        "resolve-locations --dry-run",
        "resolve-locations EVENT_ID"
      ],
      "test_instructions": "1. Run: python3 src/event_manager.py resolve-locations --dry-run\n2. Check output for resolution summary\n3. Verify pending events with generic locations are identified"
    },
    {
      "id": "telegram-bot",
      "name": "Telegram Bot for Event Submissions",
      "description": "Simple stateless Telegram bot for event submissions. Uses shared OCR infrastructure from smart_scraper for flyer processing. Supports flyer uploads with OCR, PIN publishing for trusted organizers, and contact form messages.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/telegram_bot_simple.py",
        "src/modules/smart_scraper/sources/social/telegram.py",
        "src/modules/pin_manager.py"
      ],
      "config_keys": [
        "telegram.enabled",
        "telegram.bot_token",
        "telegram.admin_chat_ids"
      ],
      "dependencies": {
        "python": [
          "python-telegram-bot>=20.0"
        ]
      },
      "cli_commands": [
        "telegram-bot"
      ],
      "test_method": "manual",
      "test_instructions": "1. Get bot token from @BotFather on Telegram\n2. Set TELEGRAM_BOT_TOKEN env var\n3. Run: python3 src/modules/telegram_bot_simple.py\n4. Send /start to your bot\n5. Test photo upload for flyer OCR (uses shared smart_scraper OCR)\n6. Test contact messages\n7. For PIN publishing: set up ORGANIZER_PIN_HASH_* secrets\n8. Verify submissions appear in assets/json/pending_events.json",
      "documentation": "docs/TELEGRAM_INTEGRATION.md"
    },
    {
      "id": "dashboard-contact-form",
      "name": "Dashboard Contact Form",
      "description": "Web-based contact form in the dashboard menu that allows users to send messages to maintainers. Includes client-side validation, responsive design, and user feedback. Future integration with Telegram Bot API for delivery.",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/html/dashboard-aside.html",
        "assets/css/style.css",
        "assets/js/forms.js"
      ],
      "config_keys": [],
      "test_method": "manual",
      "test_instructions": "1. Open the app in a browser\n2. Click the logo to open the dashboard menu\n3. Scroll to the 'Contact' section\n4. Fill in name, email, and message fields\n5. Verify validation (required fields, email format)\n6. Submit the form\n7. Verify success message appears\n8. Check that form is cleared after submission"
    },
    {
      "id": "dashboard-flyer-upload-form",
      "name": "Dashboard Flyer Upload Form",
      "description": "Web-based flyer upload form in the dashboard menu that allows users to submit event flyers (JPG, PNG, PDF). Includes file validation (size, type), responsive design, and user feedback. Future integration with Telegram Bot API for processing.",
      "category": "frontend",
      "implemented": true,
      "files": [
        "assets/html/dashboard-aside.html",
        "assets/css/style.css",
        "assets/js/forms.js"
      ],
      "config_keys": [],
      "test_method": "manual",
      "test_instructions": "1. Open the app in a browser\n2. Click the logo to open the dashboard menu\n3. Scroll to the 'Submit Event Flyer' section\n4. Fill in name and email fields\n5. Select a flyer image (JPG/PNG/PDF, max 10MB)\n6. Optionally add notes about the event\n7. Verify validation (required fields, file size, file type)\n8. Submit the form\n9. Verify success message appears\n10. Check that form is cleared after submission"
    },
    {
      "id": "telegram-bot-github-actions",
      "name": "Telegram Bot GitHub Actions Integration",
      "description": "[NOT FULLY IMPLEMENTED] Telegram integration using repository_dispatch events. The workflow exists but scripts (telegram_bot.py, manage_pins.py) are not yet created.",
      "category": "infrastructure",
      "implemented": false,
      "files": [
        ".github/workflows/telegram-bot-handler.yml"
      ],
      "config_keys": [
        "telegram.enabled",
        "telegram.bot_token",
        "telegram.admin_chat_ids"
      ],
      "dependencies": {
        "github_secrets": [
          "TELEGRAM_BOT_TOKEN",
          "ORGANIZER_PIN_HASH_1",
          "ORGANIZER_PIN_HASH_2",
          "ORGANIZER_PIN_HASH_3"
        ],
        "python": [
          "python-telegram-bot>=20.0"
        ]
      },
      "test_method": "manual",
      "test_instructions": "[Scripts not yet implemented]\n\nFuture test steps:\n1. Add TELEGRAM_BOT_TOKEN to GitHub repository secrets\n2. Create scripts/telegram_bot.py and scripts/manage_pins.py\n3. Run scripts/telegram_bot.py locally with env vars set\n4. Send a flyer photo to the bot - verify OCR processing workflow runs\n5. Send a contact message - verify GitHub issue is created\n6. For PIN publishing: add ORGANIZER_PIN_HASH_* secrets, test PIN:1234 with JSON event",
      "documentation": "docs/TELEGRAM_INTEGRATION.md"
    },
    {
      "id": "instagram-scraper",
      "name": "Instagram Event Scraper",
      "description": "Scrapes public Instagram profiles for event posts and flyers. Uses OCR to extract event information from posted images. Supports multiple Instagram accounts via config.json. Includes web search fallback for CI environments where direct Instagram access may be blocked.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/smart_scraper/sources/social/instagram.py",
        "src/modules/smart_scraper/image_analyzer/ocr.py",
        "src/modules/smart_scraper/image_analyzer/analyzer.py"
      ],
      "config_keys": [
        "scraping.sources"
      ],
      "dependencies": {
        "python": [
          "requests>=2.31.0",
          "beautifulsoup4>=4.12.0",
          "lxml>=4.9.0"
        ]
      },
      "test_method": "run_custom_test",
      "test_file": "tests/test_instagram_scraper.py",
      "test_instructions": "1. Run tests: python3 tests/test_instagram_scraper.py --verbose\n2. Add an Instagram source to config.json with type 'instagram'\n3. Run scraping: python3 src/event_manager.py scrape\n4. Verify Instagram events appear in pending_events.json",
      "documentation": "See instagram.py module docstring for configuration examples"
    },
    {
      "id": "subjective-day-api",
      "name": "Subjective Day API (NÃ¼rnberger Uhr)",
      "description": "API for calculating subjective time based on the historical NÃ¼rnberger Uhr (Nuremberg Clock) system. Available as both Python server API and client-side JavaScript for GitHub Pages hosting. Uses unequal hours where day is divided into 12 hours (sunrise to sunset) and night into 12 hours (sunset to sunrise).",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/subjective_day.py",
        "assets/js/subjective-day.js",
        "examples/subjective-day-demo.html"
      ],
      "config_keys": [],
      "dependencies": {
        "python": []
      },
      "test_method": "run_custom_test",
      "test_file": "tests/test_subjective_day.py",
      "test_instructions": "1. Run tests: python3 tests/test_subjective_day.py --verbose\n2. Start API server: python3 src/modules/subjective_day.py --serve\n3. Test endpoint: curl \"http://127.0.0.1:8080/api/subjective-time?lat=50.3167&lon=11.9167\"",
      "documentation": "See subjective_day.py module docstring for usage and historical background"
    },
    {
      "id": "constellation-viewer-api",
      "name": "Constellation Viewer API",
      "description": "ASCII art constellation viewer with visibility information. Shows major constellations with historical context about medieval timekeeping using star positions. Includes Orion, Ursa Major, Ursa Minor (Polaris), Cassiopeia, Leo, Scorpius, Cygnus, and Pleiades. wttr.in-style API with plain text and JSON output.",
      "category": "backend",
      "implemented": true,
      "files": [
        "src/modules/constellations.py"
      ],
      "config_keys": [],
      "dependencies": {
        "python": []
      },
      "test_method": "run_custom_test",
      "test_file": null,
      "test_instructions": "1. Run demo: python3 src/modules/constellations.py\n2. Start API server: python3 src/modules/constellations.py --serve --port 8081\n3. Test endpoints: curl http://127.0.0.1:8081/orion | curl http://127.0.0.1:8081/:list",
      "documentation": "See constellations.py module docstring for usage and historical context"
    }
  ]
}