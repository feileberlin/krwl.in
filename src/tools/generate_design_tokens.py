#!/usr/bin/env python3
"""
Design Token Generator

Reads design tokens from config.json and generates CSS custom properties.
This enables instant rebranding by editing the config and regenerating.

Usage:
    python3 src/tools/generate_design_tokens.py
    
Output:
    assets/html/design-tokens.css
"""

import json
import sys
from pathlib import Path
from typing import Dict, List


def load_config(base_path: Path) -> Dict:
    """Load configuration file with design tokens"""
    config_file = base_path / 'config.json'
    if not config_file.exists():
        raise FileNotFoundError(f"Config file not found: {config_file}")
    
    with open(config_file, 'r', encoding='utf-8') as f:
        return json.load(f)


def validate_design_tokens(design: Dict) -> List[str]:
    """Validate design token structure and return any warnings"""
    warnings = []
    
    # Required sections
    required_sections = ['colors', 'typography', 'spacing', 'z_index', 
                        'shadows', 'borders', 'transitions', 'branding']
    
    for section in required_sections:
        if section not in design:
            warnings.append(f"Missing section: {section}")
    
    # Validate colors
    if 'colors' in design:
        colors = design['colors']
        required_colors = ['primary', 'bg_primary', 'text_primary']
        for color in required_colors:
            if color not in colors:
                warnings.append(f"Missing required color: {color}")
    
    return warnings


def convert_to_css_var_name(key: str) -> str:
    """Convert Python key to CSS variable name"""
    # Replace underscores with hyphens for CSS convention
    return key.replace('_', '-')


def create_color_badge_url(hex_color: str) -> str:
    """
    Create a shields.io badge URL for color preview.
    
    Args:
        hex_color: Hex color code (e.g., '#D689B8' or 'D689B8')
    
    Returns:
        Shields.io badge URL for the color
    """
    # Remove '#' if present
    color = hex_color.lstrip('#')
    
    # Create shields.io badge URL
    # Format: https://img.shields.io/badge/[text]-[color]?style=flat-square
    return f"https://img.shields.io/badge/%20-%20-{color}?style=flat-square"


def is_hex_color(value: str) -> bool:
    """
    Check if a value is a hex color code.
    
    Args:
        value: String to check
    
    Returns:
        True if value is a hex color code
    """
    if not isinstance(value, str):
        return False
    
    # Remove '#' if present
    color = value.lstrip('#')
    
    # Check if it's a valid hex color (3 or 6 characters)
    if len(color) not in [3, 6]:
        return False
    
    try:
        int(color, 16)
        return True
    except ValueError:
        return False


def get_color_emoji(hex_color: str) -> str:
    """
    Get appropriate square emoji for a hex color using KISS logic.
    Uses flat colored squares (‚¨õ‚¨ú) without 3D shadow effects.
    
    Args:
        hex_color: Hex color code (e.g., '#D689B8')
    
    Returns:
        Square emoji character representing the color
    """
    color = hex_color.upper().lstrip('#')
    
    # Parse RGB
    r = int(color[0:2], 16)
    g = int(color[2:4], 16)
    b = int(color[4:6], 16)
    
    # Calculate luminance
    luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
    
    # Very light or very dark - use basic geometric squares
    if luminance > 0.95:
        return '‚¨ú'  # White square (flat, no shadow)
    elif luminance < 0.08:
        return '‚¨õ'  # Black square (flat, no shadow)
    
    # For all ecoBarbie pink/purple colors, use a simple colored block
    # Since we want flat squares without emoji shadow effects,
    # use Unicode block characters instead of colored emoji
    
    # Pink/Purple detection (all ecoBarbie colors)
    if r > b and b > g:
        return 'üü™'  # Purple square (closest to pink, but has shadow...)
    
    if abs(r - b) < 30 and r > g and b > g:
        return 'üü™'  # Purple square
    
    # For other color families (if ever used)
    if r > g and r > b:
        if r > 200:
            return 'üü•' if g < 100 else 'üüß'
        else:
            return 'üü´'
    elif g > r and g > b:
        return 'üü©'
    elif b > r and b > g:
        return 'üü¶'
    else:
        return '‚¨õ' if luminance < 0.5 else '‚¨ú'


def generate_css_custom_properties(design: Dict) -> str:
    """Generate CSS custom properties from design tokens"""
    lines = [
        "/**",
        " * Design Tokens - Auto-generated CSS Custom Properties",
        " * Generated from config.json design section",
        " * ",
        " * DO NOT EDIT THIS FILE DIRECTLY",
        " * Run: python3 src/tools/generate_design_tokens.py",
        " */",
        "",
        ":root {",
        "  /* ====================================================================== */",
        "  /* DESIGN TOKENS - Generated from config.json */",
        "  /* ====================================================================== */",
        ""
    ]
    
    # Generate color tokens
    if 'colors' in design:
        lines.append("  /* Colors */")
        for key, value in design['colors'].items():
            # Skip keys that start with underscore (comments and previews)
            if key.startswith('_'):
                css_var = convert_to_css_var_name(key)
                lines.append(f"  --color-{css_var}: {value};")
                continue
            
            css_var = convert_to_css_var_name(key)
            
            # Add the CSS variable
            lines.append(f"  --color-{css_var}: {value};")
            
            # Check if this is a hex color and add emoji badge in comment
            if is_hex_color(value):
                emoji = get_color_emoji(value)
                
                # Check if there's a corresponding _preview key for description
                preview_key = f"_preview_{key}"
                if preview_key in design['colors']:
                    preview_text = design['colors'][preview_key]
                    # Remove hex code from preview text if it starts with it (avoid duplication)
                    if preview_text.startswith(value):
                        preview_text = preview_text[len(value):].strip(' -')
                    lines.append(f"  /* {emoji} {value} {preview_text} */")
                else:
                    lines.append(f"  /* {emoji} {value} */")
        lines.append("")
    
    # Generate typography tokens
    if 'typography' in design:
        lines.append("  /* Typography */")
        for key, value in design['typography'].items():
            css_var = convert_to_css_var_name(key)
            lines.append(f"  --{css_var}: {value};")
        lines.append("")
    
    # Generate spacing tokens
    if 'spacing' in design:
        lines.append("  /* Spacing */")
        for key, value in design['spacing'].items():
            css_var = convert_to_css_var_name(key)
            lines.append(f"  --spacing-{css_var}: {value};")
        lines.append("")
    
    # Generate z-index tokens
    if 'z_index' in design:
        lines.append("  /* Z-Index Layers (4-layer system) */")
        for key, value in design['z_index'].items():
            if key.startswith('_'):  # Skip comment keys
                continue
            css_var = convert_to_css_var_name(key)
            lines.append(f"  --z-{css_var}: {value};")
        lines.append("")
    
    # Generate shadow tokens
    if 'shadows' in design:
        lines.append("  /* Shadows */")
        for key, value in design['shadows'].items():
            css_var = convert_to_css_var_name(key)
            lines.append(f"  --shadow-{css_var}: {value};")
        lines.append("")
    
    # Generate border tokens
    if 'borders' in design:
        lines.append("  /* Borders */")
        for key, value in design['borders'].items():
            css_var = convert_to_css_var_name(key)
            lines.append(f"  --border-{css_var}: {value};")
        lines.append("")
    
    # Generate transition tokens
    if 'transitions' in design:
        lines.append("  /* Transitions */")
        for key, value in design['transitions'].items():
            css_var = convert_to_css_var_name(key)
            lines.append(f"  --transition-{css_var}: {value};")
        lines.append("")
    
    lines.append("}")
    lines.append("")
    
    # Add utility classes for common patterns
    lines.extend([
        "/* Overlay positioning classes */",
        ".overlay {",
        "  position: fixed;",
        "  background: var(--color-bg-secondary);",
        "  border: var(--border-width-thin) solid var(--color-border-primary);",
        "  border-radius: var(--border-radius-medium);",
        "  box-shadow: var(--shadow-medium);",
        "}",
        "",
        ".overlay--layer-3 {",
        "  z-index: var(--z-layer-3-ui);",
        "}",
        "",
        ".overlay--layer-4 {",
        "  z-index: var(--z-layer-4-modals);",
        "}",
        "",
        ".overlay--top-left {",
        "  top: var(--spacing-md);",
        "  left: var(--spacing-md);",
        "}",
        "",
        ".overlay--top-center {",
        "  top: var(--spacing-md);",
        "  left: 50%;",
        "  transform: translateX(-50%);",
        "}",
        "",
        ".overlay--top-right {",
        "  top: var(--spacing-md);",
        "  right: var(--spacing-md);",
        "}",
        ""
    ])
    
    return '\n'.join(lines)


def main():
    """Main function"""
    print("=" * 60)
    print("üé® Design Token Generator")
    print("=" * 60)
    
    # Get base path (project root)
    base_path = Path(__file__).parent.parent.parent
    print(f"\nProject root: {base_path}")
    
    # Load config
    print("Loading config.json...")
    try:
        config = load_config(base_path)
    except FileNotFoundError as e:
        print(f"‚ùå Error: {e}")
        return 1
    
    if 'design' not in config:
        print("‚ùå Error: No 'design' section found in config.json")
        return 1
    
    design = config['design']
    print(f"‚úì Found design section with {len(design)} categories")
    
    # Validate design tokens
    print("\nValidating design tokens...")
    warnings = validate_design_tokens(design)
    if warnings:
        print("‚ö†Ô∏è  Warnings:")
        for warning in warnings:
            print(f"   - {warning}")
    else:
        print("‚úì Design tokens are valid")
    
    # Generate CSS
    print("\nGenerating CSS custom properties...")
    css = generate_css_custom_properties(design)
    
    # Write output
    output_file = base_path / 'assets' / 'html' / 'design-tokens.css'
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(css)
    
    # Count tokens
    token_count = css.count('--')
    
    print(f"‚úì Generated {token_count} CSS custom properties")
    print(f"\n‚úÖ Output: {output_file}")
    print(f"   Size: {len(css) / 1024:.1f} KB")
    print("\n" + "=" * 60)
    print("üé® Design tokens generated successfully!")
    print("=" * 60)
    
    # Show sample usage
    print("\nüí° Usage in CSS:")
    print("   color: var(--color-primary);")
    print("   background: var(--color-bg-primary);")
    print("   font-family: var(--font-family-base);")
    print("   padding: var(--spacing-md);")
    print("   z-index: var(--z-layer-3-ui);")
    print("\nüí° Instant Rebranding Workflow:")
    print("   1. Edit design section in config.json")
    print("   2. Run: python3 src/tools/generate_design_tokens.py")
    print("   3. Run: python3 src/event_manager.py generate")
    print("   4. Deploy!")
    
    return 0


if __name__ == '__main__':
    sys.exit(main())
